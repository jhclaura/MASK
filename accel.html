<!DOCTYPE html>
<html lang="en">
	<head>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
		<title>cam feed</title>
		<link rel="stylesheet" type="text/css" href="css/style.css">
	</head>
	<body>		
			<script type="text/javascript" src="js/lib/three.min_69.js"></script>
			<script src="//code.jquery.com/jquery-1.11.2.min.js"></script>

			<div id="render-canvas"></div>

			<!-- cam -->
			<p id="errorMessage" style="display:none"></p>

			<video id="video" autoplay loop width="480" height="320" style="display:none"></video>

			<!-- debugView -->
			<canvas id="layerOnVideo" width="120" height="90" style="z-index:10000000002; position:absolute; left:0px; top:0px; opacity:0.5;">
			
			<!-- put after debugView, or debugView won't show, dunno why -->
			<canvas id="videoImage" width="480" height="320" style="z-index:10000000001; position:absolute; left:0px; top:0px; display:none;">

			<script type="text/javascript">
				var video = document.getElementById('video');
				var videoImage = document.getElementById('videoImage');

				// ref: https://github.com/samdutton/simpl/blob/master/getusermedia/sources/js/main.js
				var audioSource = null, videoSource = null, camUserID = null, camEnvironmentID = null;
				var mediaConstraints = {};

				function gotSources(sourceInfos) {
					for (var i = 0; i !== sourceInfos.length; ++i) {
					    var sourceInfo = sourceInfos[i];

					   	if (sourceInfo.kind === 'video') {

					   		if (sourceInfo.facing === 'user') camUserID = sourceInfo.id;
					   		else if (sourceInfo.facing === 'environment') {

					   			camEnvironmentID = sourceInfo.id;
					   			mediaConstraints = {
									video: {
										mandatory: {
									    	maxWidth: 480,
									    	maxHeight: 320,
									    	minWidth: 480,
									    	minHeight: 320
									    },
										optional: [{sourceId: camEnvironmentID}]
									}
								};
								navigator.getUserMedia(mediaConstraints, successCallback, errorCallback);
					   		}
					   		else {
					   			camEnvironmentID = sourceInfo.id;
					   			mediaConstraints = {
									video: {
										mandatory: {
									    	maxWidth: 480,
									    	maxHeight: 320,
									    	minWidth: 480,
									    	minHeight: 320
									    },
										optional: [{sourceId: camEnvironmentID}]
									}
								};
								navigator.getUserMedia(mediaConstraints, successCallback, errorCallback);
					   		}
					    } 
					}
				}

				// for selecting back camera of phone
				if (typeof MediaStreamTrack.getSources === 'undefined'){
				  alert('This browser does not support MediaStreamTrack.\n\nTry Chrome Canary.');
				} else {
				  MediaStreamTrack.getSources(gotSources);
				}

				navigator.getUserMedia = navigator.getUserMedia || 
					navigator.webkitGetUserMedia || navigator.mozGetUserMedia;


				function successCallback(stream) {
				  // window.stream = stream; // make stream available to console
				  video.src = window.URL.createObjectURL(stream);
				  video.play();
				}

				function errorCallback(error){
					var msg = 'No camera available.';
					if (error.code == 1) 
					{   msg = 'User denied access to use camera.';   }
					document.getElementById('errorMessage').textContent = msg;
					console.log('navigator.getUserMedia error: ', error);
				}

				///////////////////////////////////////////////////////////
				///////////////////////////////////////////////////////////
				///////////////////////////////////////////////////////////
				// WebSocket_foot controller
					var handRawRotation = {}, handRotation = {};

					var host = location.origin.replace(/^http/, 'ws');
					var ws = new WebSocket(host);
					
					ws.onclose = function(){
						console.log('ws connection closed!');
					};

					ws.onopen = function(){
						console.log('ws connection open.');
					};

					var tmpX, tmpY, tmpZ;
					var filterAlpha = 0.5;

					ws.onmessage = function(msg){

						// console.log(msg);

						if(msg.data=="connect"){
							console.log("connect!");
						}

						var data = JSON.parse( msg.data );

						// var sensorValues = msg.data.split(',');
						// handRawRotation.x = sensorValues[0];
						// handRawRotation.y = sensorValues[1];
						// handRawRotation.z = sensorValues[2];

						// console.log( data );
						// low pass filter!
							// accelReading.x = data.x * filterAlpha + (accelReading.x * (1.0 - filterAlpha));
							// accelReading.y = data.y * filterAlpha + (accelReading.y * (1.0 - filterAlpha));
							// accelReading.z = data.z * filterAlpha + (accelReading.z * (1.0 - filterAlpha));



						if(data.l==0){
							accelReading.x = data.x;
							accelReading.y = data.y;
							accelReading.z = data.z;
						}

						if(data.l==1){

							magReading.h = data.h;

							// console.log("mag.x: " + magReading.x);
							// console.log("mag.y: " + magReading.y);
							// console.log("mag.z: " + magReading.z);
						}

					};
					
					var xTotal=0, yTotal=0;
					// To reCalibrate the sensor
					function calibrate(){
						xTotal=0;
						yTotal=0;

						xMin = 9999999;
						xMax = 0;
						yMin = 9999999;
						yMax = 0;

						var duration = 3000;
						var divider = 0;

						var motorTime = Date.now();

						
						while(motorTime+duration > Date.now()){
							var rawX = parseInt(UD);
							var rawY = parseInt(LR);

							xTotal += rawX;
							yTotal += rawY;

							if(rawX<xMin){
							  xMin = rawX;
							}
							else if(rawX>xMax){
							  xMax = rawX;
							}

							if(rawY<yMin){
							  yMin = rawY;
							}
							else if(rawY>yMax){
							  yMax = rawY;
							}

							divider++;
						}
						
						xCenter = xTotal/divider;
						yCenter = yTotal/divider;

						// for(var i=0; i<1000; i++){
						// 	xTotal += parseInt(UD);
						// 	yTotal += parseInt(LR);
						// }
						// xCenter = xTotal/1000;
						// yCenter = yTotal/1000;

						// console.log(xTotal);
						// console.log(divider);
						console.log("finished calibrate!");
					}

				//SYNCING_ISSUE
				//http://stackoverflow.com/questions/23898477/tornado-websockets-invalidstateerror-still-in-connecting-state
				//but has better solution... e.g. promises
				function sendMessage(msg) {
			        waitForSocketConnection(ws, function() {
			            ws.send( msg );
			        });

			        // console.log('* sendMessage');
			    };


				function waitForSocketConnection(socket, callback){
			        setTimeout(
			            function(){
			                if (socket.readyState === 1) {
			                    if(callback !== undefined){
			                        callback();

			                        // console.log('* callback');
			                    }
			                    return;
			                } else {
			                    waitForSocketConnection(socket,callback);
			                }
			            }, 5);

			        // console.log('* waitForSocketConnection');
			    };
			</script>


			<script type="text/javascript" src="js/controls/PointerLockControls.js"></script>
			<script src="js/StereoEffect.js"></script>
  			<script src="js/controls/DeviceControls_accel.js"></script>
			<script type="text/javascript" src="js/Detector.js"></script>
			<script type="text/javascript" src="js/KeyboardState.js"></script>
			<script type="text/javascript" src="js/lib/tween.min.js"></script>
			<script type="text/javascript" src="js/stats.min.js"></script>
			<script type="text/javascript" src="js/wave.js"></script>

			<script type="text/javascript" src="js/jsfeat-min.js"></script>
			<script type="text/javascript" src="js/cascades/bbf_face.js"></script>

			<script type="text/javascript" src="js/script_accel.js"></script>
	</body>
</html>
