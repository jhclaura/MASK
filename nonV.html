<!DOCTYPE html>
<html lang="en">
	<head>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
		<title>cam feed</title>
		<link rel="stylesheet" type="text/css" href="css/style.css">
	</head>
	<body>		
			<script type="text/javascript" src="js/lib/three.min_69.js"></script>
			<script src="//code.jquery.com/jquery-1.11.2.min.js"></script>

			<div id="render-canvas"></div>

			<!-- cam -->
			<p id="errorMessage" style="display:none"></p>

			<video id="video" autoplay loop width="480" height="320" style="display:none"></video>

			<!-- debugView -->
			<canvas id="layerOnVideo" width="120" height="80" style="z-index:10000000002; position:absolute; left:0px; top:0px; opacity:1;">
			
			<!-- put after debugView, or debugView won't show, dunno why -->
			<canvas id="videoImage" width="480" height="320" style="z-index:10000000001; position:absolute; left:0px; top:0px; display:none;">

			<script type="text/javascript">
				var video = document.getElementById('video');
				var videoImage = document.getElementById('videoImage');

				// ref: https://github.com/samdutton/simpl/blob/master/getusermedia/sources/js/main.js
				var audioSource = null, videoSource = null, camUserID = null, camEnvironmentID = null;
				var mediaConstraints = {};

				function gotSources(sourceInfos) {
					for (var i = 0; i !== sourceInfos.length; ++i) {
					    var sourceInfo = sourceInfos[i];

					   	if (sourceInfo.kind === 'video') {

					   		if (sourceInfo.facing === 'user') camUserID = sourceInfo.id;
					   		else if (sourceInfo.facing === 'environment') {

					   			camEnvironmentID = sourceInfo.id;
					   			mediaConstraints = {
									video: {
										mandatory: {
									    	maxWidth: 480,
									    	maxHeight: 320,
									    	minWidth: 480,
									    	minHeight: 320
									    },
										optional: [{sourceId: camEnvironmentID}]
									}
								};
								navigator.getUserMedia(mediaConstraints, successCallback, errorCallback);
					   		}
					   		else {
					   			camEnvironmentID = sourceInfo.id;
					   			mediaConstraints = {
									video: {
										mandatory: {
									    	maxWidth: 480,
									    	maxHeight: 320,
									    	minWidth: 480,
									    	minHeight: 320
									    },
										optional: [{sourceId: camEnvironmentID}]
									}
								};
								navigator.getUserMedia(mediaConstraints, successCallback, errorCallback);
					   		}
					    } 
					}
				}

				// for selecting back camera of phone
				if (typeof MediaStreamTrack.getSources === 'undefined'){
				  alert('This browser does not support MediaStreamTrack.\n\nTry Chrome Canary.');
				} else {
				  MediaStreamTrack.getSources(gotSources);
				}

				navigator.getUserMedia = navigator.getUserMedia || 
					navigator.webkitGetUserMedia || navigator.mozGetUserMedia;


				function successCallback(stream) {
				  // window.stream = stream; // make stream available to console
				  video.src = window.URL.createObjectURL(stream);
				  video.play();
				}

				function errorCallback(error){
					var msg = 'No camera available.';
					if (error.code == 1) 
					{   msg = 'User denied access to use camera.';   }
					document.getElementById('errorMessage').textContent = msg;
					console.log('navigator.getUserMedia error: ', error);
				}

			</script>

			<!-- source: http://wemadeyoulook.at/en/blog/spherical-harmonics-distortion-first-experiment-webgl/ -->
			<script type="x-shader/x-vertex" id="vertexShader">
				#define TWOPI 6.28318531
				#define PI    3.14159265

				varying vec3 vRgb;
				uniform float time;
				uniform float m[8];
				uniform float m2[8];

				uniform float hue;
				uniform float distortion;

				float HueToRGB(float f1, float f2, float hue) {
					if (hue < 0.0)
						hue += 1.0;
					else if (hue > 1.0)
						hue -= 1.0;
					float res;
					if ((6.0 * hue) < 1.0)
						res = f1 + (f2 - f1) * 6.0 * hue;
					else if ((2.0 * hue) < 1.0)
						res = f2;
					else if ((3.0 * hue) < 2.0)
						res = f1 + (f2 - f1) * ((2.0 / 3.0) - hue) * 6.0;
					else
						res = f1;
					return res;
				}

				vec3 HSLToRGB(vec3 hsl) {
					vec3 rgb;
					if (hsl.y == 0.0)
						rgb = vec3(hsl.z); // Luminance
					else {
						float f2;

						if (hsl.z < 0.5)
							f2 = hsl.z * (1.0 + hsl.y);
						else
							f2 = (hsl.z + hsl.y) - (hsl.y * hsl.z);

						float f1 = 2.0 * hsl.z - f2;

						rgb.r = HueToRGB(f1, f2, hsl.x + (1.0/3.0));
						rgb.g = HueToRGB(f1, f2, hsl.x);
						rgb.b = HueToRGB(f1, f2, hsl.x - (1.0/3.0));
					}
					return rgb;
				}	

				void main() {
				    vec3 p = normalize(position);
				    
				    // convert from xyz to spherical coordinates
				    float phi = acos(p.z);
				    float S = max(sqrt(p.x * p.x + p.y * p.y), 0.000001);
					float theta = asin(p.y / S);

				    if(p.x < 0.0) {
				    	theta = PI - theta;
				    }
				    
				    // then do radius magic
				    float fade = 0.5 + sin(time * 0.3) * sin(time * 0.19) * 0.5;
					float r1 = 0.0;
				    r1 += pow(sin(m[0]*phi),m[1]);
				    r1 += pow(cos(m[2]*phi),m[3]);
				    r1 += pow(sin(m[4]*theta),m[5]);
				    r1 += pow(cos(m[6]*theta),m[7]);

					float r2 = 0.0;
				    r2 += pow(sin((m2[0])*phi),m2[1]);
				    r2 += pow(cos((m2[2])*phi),m2[3]);
				    r2 += pow(sin((m2[4])*theta),m2[5]);
				    r2 += pow(cos((m2[6])*theta),m2[7]);

				    float r = (r1 + fade * (r2 - r1)); 
				    float premul = length(position) * ((1.0 - distortion) + r * distortion);
				    p.x = premul * sin(phi) * cos(theta);
				    p.y = premul * sin(phi) * sin(theta);
				    p.z = premul * cos(phi);

				    float a = 0.5 + sin(theta * 4.0) * 0.125;
				    float b = cos(phi*2.0) * sin(theta * 3.0) * 0.125;
				    vec3 hsl = vec3(b*r*0.25 + hue, a*r*0.5, r*0.35);
				    vRgb = HSLToRGB(hsl);
		 
				    gl_Position = projectionMatrix * modelViewMatrix * vec4( p, 1.0 );
				} 	
			</script>

			<script type="x-shader/x-vertex" id="fragmentShader">
				varying vec3 vRgb;

				void main() {

				    // colour is RGBA: u, v, 0, 1
				    gl_FragColor = vec4( vRgb, 1.0 );
				}    
			</script>

			<script type="x-shader/x-vertex" id="vertexshader_T">

				uniform float amplitude;
				attribute vec3 customColor;
				attribute vec3 displacement;
				varying vec3 vNormal;
				varying vec3 vColor;

				void main() {
					vNormal = normal;
					vColor = customColor;

					vec3 newPosition = position + amplitude + displacement;
					gl_Position = projectionMatrix * modelViewMatrix * vec4(newPosition, 1.0);
				}
			</script>

			<script type="x-shader/x-fragment" id="fragmentshader_T">

				varying vec3 vNormal;
				varying vec3 vColor;

				void main() {
					const float ambient = 0.05;

					vec3 light = vec3(0, 1.0, 0);
					vec3 lightUp = vec3(0, -1.0, 0);

					float directional = max( dot(vNormal, light), 0.0 );
					directional = max( directional, dot(vNormal, lightUp));

					gl_FragColor = vec4( (directional + ambient) * vColor, 1.0);
					gl_FragColor.xyz = sqrt( gl_FragColor.xyz );
				}
			</script>
			

			<script src="js/StereoEffect.js"></script>
  			<script src="js/controls/DeviceControls_vN4.js"></script>
			<script type="text/javascript" src="js/Detector.js"></script>
			<script type="text/javascript" src="js/BufferLoader.js"></script>
			<script type="text/javascript" src="js/KeyboardState.js"></script>
			<script type="text/javascript" src="js/lib/tween.min.js"></script>
			<script type="text/javascript" src="js/stats.min.js"></script>
			<script type="text/javascript" src="js/sample_puppet.js"></script>
			<script type="text/javascript" src="js/wave.js"></script>

			<script type="text/javascript" src="js/jsfeat-min.js"></script>
			<script type="text/javascript" src="js/cascades/bbf_face.js"></script>
			<script type="text/javascript" src="js/cascades/frontalface.js"></script>
			<script type="text/javascript" src="js/cascades/handopen.js"></script>
			<script type="text/javascript" src="js/cascades/handfist.js"></script>
			<script type="text/javascript" src="js/modifiers/TessellateModifier.js"></script>
			<script type="text/javascript" src="js/ImprovedNoise.js"></script>
			<script type="text/javascript" src="js/script_nonV_2.js"></script>
	</body>
</html>
